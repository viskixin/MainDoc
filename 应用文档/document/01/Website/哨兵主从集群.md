# 摘要说明

```markdown
# 使用 Docker
创建 → 哨兵模式集群

# 参数说明
-i(--interactive)	保持容器的标准输入(stdin)打开，即使没有连接到容器(通常与 -t 一起使用，以便能够交互式地运行命令)
-t(--tty)			为容器分配一个伪终端(pseudo-tty)，这样就可以在容器内运行命令行程序
-d(--detach)		以分离模式(detached mode)运行容器，即在后台运行并返回容器ID；意味着可以在不阻塞终端的情况下启动容器
```

其他参考：[Docker搭建Redis主从复制集群](https://blog.csdn.net/qq_43753724/article/details/120390533) | [Docker搭建Redis哨兵模式集群](https://download.csdn.net/blog/column/10939729/120393724)

# 默认方式

```shell
# 前提条件
1) 创建 Redis 配置文件
touch /docker-software/redis/redis_{6379,6380,6381}.conf
mkdir /docker-software/redis/data/d_{6379,6380,6381}
touch /docker-software/redis/logs/{6379,6380,6381}.log

2) redis_6379.conf、redis_6380.conf、redis_6381.conf
★ 重要修改配置如下
port 6380
pidfile /var/run/redis_6380.pid
logfile "/etc/redis/logs/6380.log"
dir /etc/redis/data/d_6380
★ 需要注释掉bind
# bind 127.0.0.1  容器ip
★ 配置主从复制(可选，在指令中可配置)
replicaof 192.168.145.121 6379   # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof
★ 配置从节点只读
replica-read-only yes
★ 解除保护模式(开启的话，只有本机才可以访问redis)
protected-mode no

3) 创建 Sentinel 配置文件
touch /docker-software/redis/sentinel_{26379,26380,26381}.conf
mkdir /docker-software/redis/data/sd_{26379,26380,26381}
touch /docker-software/redis/logs/s_{26379,26380,26381}.log

4) sentinel_26379.conf、sentinel_26380.conf、sentinel_26381.conf
★ 重要配置如下(注意：需要监听虚拟机节点，而非容器节点)
port 26380
dir /tmp
#sentinel monitor mymaster redis-master 6379 2
#sentinel monitor mymaster 172.17.0.5 6379 2 # ×
sentinel monitor mymaster 192.168.145.121 6379 2
sentinel auth-pass mymaster 123456
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1

5) 授权
chmod -R 777 /docker-software/redis
```

配置文件详见：[docker-software](.\document\docker-software.tar.gz)

## 主从节点

```bash
# 启动 Redis 主节点
docker run --name redis-master -p 6379:6379 --privileged=true \
-v /docker-software/redis/redis_6379.conf:/etc/redis/redis_6379.conf \
-v /docker-software/redis/data/d_6379:/etc/redis/data/d_6379 \
-v /docker-software/redis/logs/6379.log:/etc/redis/logs/6379.log \
-d redis:latest redis-server /etc/redis/redis_6379.conf \
--requirepass 123456 --appendonly yes
# 查看 redis-master 容器信息，可找到容器IP
docker inspect redis-master
"IPAddress": "172.17.0.5"

# 启动 Redis 从节点1
  --link redis-master:redis → 将 redis-master 容器链接到从节点容器，并将其命名为 redis_m
  --slaveof redis 6379 → 指定主节点容器的名称为 redis，端口号为 6379
docker run --name redis-slave1 -p 6380:6380 --link redis-master:redis_m --privileged=true \
-v /docker-software/redis/redis_6380.conf:/etc/redis/redis_6380.conf \
-v /docker-software/redis/data/d_6380:/etc/redis/data/d_6380 \
-v /docker-software/redis/logs/6380.log:/etc/redis/logs/6380.log \
-d redis:latest redis-server /etc/redis/redis_6380.conf \
--slaveof redis_m 6379 --masterauth 123456 --requirepass 123456 --appendonly yes

# 启动 Redis 从节点2
  --masterauth 123456 → 告诉从节点使用123456密码认证主节点
  --requirepass 123456 → 设置从节点本身的访问密码
docker run --name redis-slave2 -p 6381:6381 --link redis-master:redis_m --privileged=true \
-v /docker-software/redis/redis_6381.conf:/etc/redis/redis_6381.conf \
-v /docker-software/redis/data/d_6381:/etc/redis/data/d_6381 \
-v /docker-software/redis/logs/6381.log:/etc/redis/logs/6381.log \
-d redis:latest redis-server /etc/redis/redis_6381.conf \
--slaveof redis_m 6379 --masterauth 123456 --requirepass 123456 --appendonly yes
```

## 哨兵模式

```bash
# 哨兵1
docker run -d --name redis-sentinel1 -p 26379:26379 \
-v /docker-software/redis/sentinel_26379.conf:/etc/redis/sentinel_26379.conf \
-v /docker-software/redis/data/sd_26379:/etc/redis/data/sd_26379 \
-v /docker-software/redis/logs/s_26379.log:/etc/redis/logs/s_26379.log \
redis:latest redis-sentinel /etc/redis/sentinel_26379.conf

# 哨兵2
docker run --name redis-sentinel2 -p 26380:26380 \
-v /docker-software/redis/sentinel_26380.conf:/etc/redis/sentinel_26380.conf \
-v /docker-software/redis/data/sd_26380:/etc/redis/data/sd_26380 \
-v /docker-software/redis/logs/s_26380.log:/etc/redis/logs/s_26380.log \
-d redis:latest redis-sentinel /etc/redis/sentinel_26380.conf

# 哨兵3
docker run --name redis-sentinel3 -p 26381:26381 \
-v /docker-software/redis/sentinel_26381.conf:/etc/redis/sentinel_26381.conf \
-v /docker-software/redis/data/sd_26381:/etc/redis/data/sd_26381 \
-v /docker-software/redis/logs/s_26381.log:/etc/redis/logs/s_26381.log \
-d redis:latest redis-sentinel /etc/redis/sentinel_26381.conf
```

# 自定义域方式

```shell
# 前提条件
1) 创建一个自定义 Docker 网络 (默认创建一个名为 bridge 的网络)
docker network create redis-net
2) 查看 network
docker network ls
docker network inspect redis-net
★ 删除 network
docker network rm redis-net
3) 启动 Redis 主节点和从节点，并将其连接到自定义网络 redis-net
如下所示：
```

## 主从节点

```bash
# 主节点
docker run --name redis-master -p 6379:6379 --network redis-net --privileged=true \
-v /docker-software/redis/redis_6379.conf:/etc/redis/redis_6379.conf \
-v /docker-software/redis/data/d_6379:/etc/redis/data/d_6379 \
-v /docker-software/redis/logs/6379.log:/etc/redis/logs/6379.log \
-d redis:latest redis-server /etc/redis/redis_6379.conf \
--requirepass 123456 --appendonly yes

# 从节点1
docker run --name redis-slave1 -p 6380:6380 --network redis-net --privileged=true \
-v /docker-software/redis/redis_6380.conf:/etc/redis/redis_6380.conf \
-v /docker-software/redis/data/d_6380:/etc/redis/data/d_6380 \
-v /docker-software/redis/logs/6380.log:/etc/redis/logs/6380.log \
-d redis:latest redis-server /etc/redis/redis_6380.conf \
--slaveof redis-master 6379 --masterauth 123456 --requirepass 123456 --appendonly yes

# 从节点2
docker run --name redis-slave2 -p 6381:6381 --network redis-net --privileged=true \
-v /docker-software/redis/redis_6381.conf:/etc/redis/redis_6381.conf \
-v /docker-software/redis/data/d_6381:/etc/redis/data/d_6381 \
-v /docker-software/redis/logs/6381.log:/etc/redis/logs/6381.log \
-d redis:latest redis-server /etc/redis/redis_6381.conf \
--slaveof redis-master 6379 --masterauth 123456 --requirepass 123456 --appendonly yes
```

## 哨兵模式

```bash
# 哨兵1
docker run -d --name redis-sentinel1 -p 26379:26379 --network redis-net \
-v /docker-software/redis/sentinel_26379.conf:/etc/redis/sentinel_26379.conf \
-v /docker-software/redis/data/sd_26379:/etc/redis/data/sd_26379 \
-v /docker-software/redis/logs/s_26379.log:/etc/redis/logs/s_26379.log \
redis:latest redis-sentinel /etc/redis/sentinel_26379.conf

# 哨兵2
docker run --name redis-sentinel2 -p 26380:26380 --network redis-net \
-v /docker-software/redis/sentinel_26380.conf:/etc/redis/sentinel_26380.conf \
-v /docker-software/redis/data/sd_26380:/etc/redis/data/sd_26380 \
-v /docker-software/redis/logs/s_26380.log:/etc/redis/logs/s_26380.log \
-d redis:latest redis-sentinel /etc/redis/sentinel_26380.conf

# 哨兵3
docker run --name redis-sentinel3 -p 26381:26381 --network redis-net \
-v /docker-software/redis/sentinel_26381.conf:/etc/redis/sentinel_26381.conf \
-v /docker-software/redis/data/sd_26381:/etc/redis/data/sd_26381 \
-v /docker-software/redis/logs/s_26381.log:/etc/redis/logs/s_26381.log \
-d redis:latest redis-sentinel /etc/redis/sentinel_26381.conf
```

# 认证连接

## 主从节点

```markdown
1) 进入主节点
docker exec -it redis-master bash
2) 'xxx may not be safe' 不安全，所以是临时的
redis-cli -h localhost -p 6379 -a 123456 info replication
★ 上述为一次性命令，单次只进入，后续可以持续输入命令
redis-cli -h 127.0.0.1 -p 6379
auth 123456
info replication
★ 默认ip为 localhost，可省略；默认port为 6379，可省略
redis-cli
auth 123456
```

## 哨兵模式

```markdown
1) 进入任意一个哨兵实例
docker exec -it redis-sentinel1 bash
2) 验证哨兵集群是否正常工作
redis-cli -h 127.0.0.1 -p 26379 sentinel get-master-addr-by-name mymaster
★ 上述为一次性命令，单次只进入，后续可以持续输入命令
redis-cli -h localhost -p 26379
sentinel get-master-addr-by-name mymaster
info sentinel
exit
★ 默认ip为 localhost，可省略；默认port为 6379，不可省略
redis-cli -p 26379
sentinel get-master-addr-by-name mymaster
exit
★ redis-cli -p <sentinel_port> sentinel get-master-addr-by-name <master_name>
  <sentinel_port> 是哨兵服务的端口号
  <master_name> 是你在哨兵配置中定义的主节点名称
redis-cli -p 26379 sentinel get-master-addr-by-name mymaster
3) 假设返回的主节点地址是 192.168.145.121，端口是 6379，连接到该主节点
redis-cli -h 192.168.145.121 -p 6379
auth 123456
```

